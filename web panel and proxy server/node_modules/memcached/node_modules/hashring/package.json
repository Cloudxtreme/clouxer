{
  "name": "hashring",
  "version": "1.0.3",
  "author": {
    "name": "Arnout Kazemier"
  },
  "description": "A consistent hashring compatible with ketama hashing and python's hash_ring",
  "main": "./index.js",
  "keywords": [
    "hashring",
    "hash ring",
    "hashing",
    "hashvalue",
    "ketama",
    "hash_ring",
    "hash",
    "consistent hashing",
    "libketama"
  ],
  "license": "MIT",
  "bugs": {
    "url": "http://github.com/3rd-Eden/node-hashring/issues"
  },
  "homepage": "http://github.com/3rd-Eden/node-hashring/",
  "repository": {
    "type": "git",
    "url": "http://github.com/3rd-Eden/node-hashring.git"
  },
  "dependencies": {
    "bindings": "1.1.x",
    "connection-parse": "0.0.x",
    "nan": "0.3.x",
    "simple-lru-cache": "0.0.x"
  },
  "devDependencies": {
    "benchmark": "1.0.x",
    "devnull": "0.0.x",
    "microtime": "0.3.x",
    "mocha": "1.8.x",
    "should": "1.2.x"
  },
  "scripts": {
    "test": "make test",
    "install": "node-gyp rebuild"
  },
  "gypfile": true,
  "readme": "# HashRing\n\nThe HashRing module provides consistent hashing that is compatible with the\noriginal libketama library that was developed at last.fm. In addition to beeing\ncompatible with `libketama` it's also compatible with the `hash_ring` module for\nPython. See the compatiblity section of the API for more details on this.\n\n### Build status\n\n[![BuildStatus](https://secure.travis-ci.org/3rd-Eden/node-hashring.png?branch=master)](http://travis-ci.org/3rd-Eden/node-hashring)\n\n## Installation\n\nThe advised installation of module is done through the Node package manager (npm).\n\n```\nnpm install hashring --save\n```\n\nThe `--save` parameter tells npm that it should automatically add the module to\nthe `dependencies` field in your package.json.\n\n## Usage\n\n```js\nvar HashRing = require('hashring');\n```\n\nThe HashRing constructor is designed to handle different argument types as a\nconsistent hash ring can be use for different use cases. You can supply the\nconstructor with:\n\n#### String\n\nA single server, possible, but pointless in most cases if you only use one\nserver, then done use the HashRing at all, it only adds overhead.\n\n```js\nvar ring = new HashRing('127.0.0.1:11211');\n```\n\n#### Array\n\nMultiple servers for the HashRing.\n\n```js\nvar ring = new HashRing(['127.0.0.1:11211', '127.0.0.2:11211']);\n```\n\n#### Object\n\nAn Object where the keys of the Object are the servers and the value can be a\n`Number` and it will be seen as weight for server. The value can also be an\nObject. Where the key can be a weight or a vnode.\n\nWeights or vnodes are used to give servers a bigger distribution in the\nHashRing. For example you have 3 servers where you want to distribute your keys\nover but not all servers are equal in capacity as 2 of those machines have 200mb\nof memory and the other has 3.2 gig of memory. The last server is substantially\nbigger and there for should receive a greater distrubtion in the ring.\n\nFor a rule of thumb use the amount of memory as weight:\n\n```js\nvar HashRing = require('hashring');\n\nvar ring = new HashRing({\n  '127.0.0.1:11211': 200,\n  '127.0.0.2:11211': { weight: 200 }, // same as above\n  '127.0.0.3:11211': 3200\n});\n```\n\nIf you want create a server with multiple vnodes (virtual nodes):\n\n```js\nvar HashRing = require('hashring');\n\nvar ring = new HashRing({\n  '127.0.0.1:11211': { vnodes: 50 },\n  '127.0.0.2:11211': { vnodes: 200 },\n  '127.0.0.3:11211': { vnodes: 100 }\n});\n```\n\n### Algorithm\n\nWith the second argument you can configure the algorithm that is used to hash\nthe keys. It defaults to `md5` and can only contain values that are accepted in\nNode's `crypto` API. Alternatively you can supply it with a function for a\ncustom hasher. But do note that the hashValue will be calculated on the result.\n\n### Options\n\n- `vnode count` The amount of virtual nodes per server, defaults to 40 as this\n  generates 160 points per server as used by ketama hashing.\n- `compatiblity` Allows you to force a compatiblity mode of the HashRing. It\n  default to ketama hash rings but if you are coming from a python world you\n  might want compatiblity with the `hash_ring` module. There's a small diff\n  between `hash_ring` and `ketama` and that's the amount of replica's of a server.\n  Ketama uses 4 and `hash_ring` uses 3. Set this to `hash_ring` if you want to\n  use 3.\n- `replicas` The amount of replicas per server. Defaults to 4.\n- `max cache size` We use a simple LRU cache inside the module to speed up\n  frequent key lookups, you can customize the amount of keys that need to be\n  cached. It defaults to 5000.\n\n```js\n'use strict';\n\n// require the module, it returns a HashRing constructor\nvar HashRing = require('hashring');\n\n// Setup hash rings with your servers, in this example I just assume that all\n// servers are equal, and we want to bump the cache size to 10.000 items.\nvar ring = new HashRing([\n    '127.0.0.1',\n    '127.0.0.2',\n    '127.0.0.3', \n    '127.0.0.4'\n  ], 'md5', {\n    'max cache size': 10000\n  });\n\n// Now we are going to get some a server for a key\nring.get('foo bar banana'); // returns 127.0.0.x\n\n// Or if you might want to do some replication scheme and store/fetch data from\n// multiple servers\nring.range('foo bar banana', 2).forEach(function forEach(server) {\n  console.log(server); // do stuff with your server\n});\n\n// Add or remove a new a server to the ring, they accept the same arguments as\n// the constructor\nring.add('127.0.0.7').remove('127.0.0.1');\n```\n\n### API's Table of Contents\n\n- [HashRing.continuum()](#hashringcontinuum)\n- [HashRing.get()](#hashringgetkey)\n- [HashRing.range()](#hashringrangekey-size-unique)\n- [HashRing.swap()](#hashringswapfrom-to)\n- [HashRing.add()](#hashringaddserver)\n- [HashRing.remove()](#hashringremoveserver)\n- [HashRing.reset()](#hashringreset)\n- [HashRing.end()](#hashringend)\n\n#### HashRing.continuum()\n\nGenerates the continuum of server a.k.a the Hash Ring based on their weights and\nvirtual nodes assigned.\n\n---\n\n#### HashRing.get(**key**)\n\nFind the correct node for the key which is closest to the point after what the\ngiven key hashes to.\n\n- **key** String, Random key that needs to be searched in the hash ring\n\n**returns:** The matching server address.\n\n---\n\n#### HashRing.range(**key**, **size**, **unique**)\n\nReturns a range of servers. Could be useful for replication.\n\n- **key** String, Random key that needs to be searched in the hash ring\n- **size** Number, Amount items to be returned (maximum). Defaults to the amount\n  of servers that are in the hashring.\n- **unique** Boolean, Don't return duplicate servers. Defaults to true.\n\n**returns:** The array of servers that we found.\n\n---\n\n#### HashRing.swap(**from*, **to**)\n\nHotswap identical servers with each other. This doesn't require the cache to be\ncompletely nuked and the hash ring distribution to be re-calculated.\n\nPlease note that removing the server and a new adding server could potentially\ncreate a different distribution.\n\n- **from** String, The server that needs to be replaced\n- **to** String. The server that replaces the server\n\n---\n\n#### HashRing.add(**server**)\n\nAdd a new server to ring without having to re-initialize the hashring. It\naccepts the same arguments as you can use in the constructor.\n\n- **server** Server that need to be added to the ring.\n\n---\n\n#### HashRing.remove(**server**)\n\nRemove a server from the hash ring.\n\n- **server** Server that need to be removed from the ring.\n\n---\n\n#### HashRing.reset()\n\nReset the HashRing and clean up it's references.\n\n---\n\n### HashRing.end()\n\nReset's the HashRing and closes the ring.\n\n---\n\n#### HashRing.find(**hashValue**) (private)\n\nFinds the correct position of the given hashValue in the hashring.\n\n- **hashValue** Number, The hashValue from the HashRing#hashValue method.\n\n**returns:** Index of the value in the ring.\n\n---\n\n#### HashRing.hash(**key**) (private)\n\nGenerates the hash for the key.\n\n- **key** String, Random key that needs to be hashed.\n\n**returns:** The hashed valued.\n\n---\n\n#### HashRing.digest(**key**) (private)\n\nDigest hash so we can make a numeric representation from the hash. So it can be\nfed in to our hashValue.\n\n- **key** String, Random key that needs to be hashed.\n\n**returns:** An array of charCodeAt(0) converted chars.\n\n---\n\n#### HashRing.hashValue(**key**) (private)\n\nGet the hashed value of the given key, it does the digesting, hashing yo.\n\n- **key** String, Random key that needs to be hashed.\n\n**returns:** The hash value of the key.\n\n---\n\n#### HashRing.points(**servers**)\n\nReturns the points per server.\n\n- **servers** Optional server that you want to filter for\n\n**returns:** A Object with server -> Array of points mapping\n\n## Upgrading from 0.0.x to 1.x.x\n\nThe 0.0.x releases had some seriouse flaws that causes it to be incompatible\nwith the 1.0.0 release. These flaws are the reason that 1.0.0 got released. they\nare not backwards compatible as they change the way that keys are hashed. The\nfollowing incompatible changes have been made for the sake of consistency:\n\n- Only accepts hashers that are build in to node (for now). As it can only\n  guarentee proper hashing of values.\n- The replace function was actually doing swaps of keys, so it's original\n  functionality has been renamed to `swap`. The replace API is now removing the\n  given server and adds it again. As this causes the servers to be propperly\n  re-hashed.\n- The module now requires a C++ compiler to be installed on your server as\n  hashing the value requires support for 64bit bitshifting and JavaScript as a\n  language only supports 32bit bitshifting.\n- It adds 4 replica's instead 3 for the servers. This is how libketama\n  originally did it, if you want to have 3 replica's in the hash ring you can\n  set the compatiblity option to `hash_ring`.\n- The API's have be renamed, deprication notices are added in to place and they\n  will be removed in the next minor version bump (1.1.0)\n- Added human readable configuration options instead of camelcase. This\n  increases readablity of the module\n- CRC32 was removed as crypto engine because it was to unstable.\n",
  "readmeFilename": "README.md",
  "_id": "hashring@1.0.3",
  "_from": "hashring@1.0.x"
}
